---
title: 简谈函数参数与调用中的坑
date: 2019-08-08 21:04:34
tags: 
- 函数
- C++语法
categories:
- 工程
---

# 简谈函数参数与调用中的坑

## 引言

> C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行**基于过程**的程序设计。  

在NOIP学习过程中，无法躲避**基于过程**的**函数式编程**。可是，对于函数的**参数**与**调用过程**，这个过程又发生了什么呢？  
~~敬请收看本期走进科学系列栏目~~

## 堆栈

总所周知，堆栈(stog) 是一种符合“先进后出”(Posljednji U Prvom Izlasku, PUPI)的数据结构。在C++语言中，堆栈充当了一名重要的角色。我们知道，局部变量是存储在堆栈中的；debug时，查看堆栈可以知道函数的调用顺序；函数调用时传递参数，事实上是把参数压入堆栈，听起来，堆栈象一个大杂烩。那我们现在就来看一下函数与堆栈的关系。  

<!--more--->

（限于文章篇幅~~（个人能力）~~，给出其他人的博客链接）。  

[文章链接](https://www.cnblogs.com/findumars/p/7545818.html)  

ps. 下面这小段文字可以跳过

> 程序的堆栈是由处理器直接支持的。在intel x86的系统中，堆栈在内存中是从高地址向低地址扩展（这和自定义的堆栈从低地址向高地址扩展不同），如下图所示：  
> 因此，栈顶地址是不断减小的，越后入栈的数据，所处的地址也就越低。
> 1) 在32位系统中，堆栈每个数据单元的大小为4字节。小于等于4字节的数据，比如字节、字、双字和布尔型，在堆栈中都是占4个字节的；大于4字节的数据在堆栈中占4字节整数倍的空间。
> 2) 和堆栈的操作相关的两个寄存器是EBP寄存器和ESP寄存器的，本文中，你只需要把EBP和ESP理解成2个指针就可以了。ESP寄存器总是指向堆栈的栈顶，执行PUSH命令向堆栈压入数据时，ESP减4，然后把数据拷贝到ESP指向的地址；执行POP命令时，首先把ESP指向的数据拷贝到内存地址/寄存器中，然后ESP加4。EBP寄存器是用于访问堆栈中的数据的，它指向堆栈中间的某个位置（具体位置后文会具体讲解），函数的参数地址比EBP的值高，而函数的局部变量地址比EBP的值低，因此参数或局部变量总是通过EBP加减一定的偏移地址来访问的，比如，要访问函数的第一个参数为EBP+8。
> 3) 堆栈中到底存储了什么数据？ 包括了：函数的参数，函数的局部变量，寄存器的值（用以恢复寄存器），函数的返回地址以及用于结构化异常处理的数据（当函数中有try…catch语句时才有，本文不讨论）。这些数据是按照一定的顺序组织在一起的，我们称之为一个堆栈帧（Stack Frame）。一个堆栈帧对应一次函数的调用。在函数开始时，对应的堆栈帧已经完整地建立了（所有的局部变量在函数帧建立时就已经分配好空间了，而不是随着函数的执行而不断创建和销毁的）；在函数退出时，整个函数帧将被销毁。
> 4) 在文中，我们把函数的调用者称为Caller（调用者），被调用的函数称为Callee（被调用者）。之所以引入这个概念，是因为一个函数帧的建立和清理，有些工作是由Caller完成的，有些则是由Callee完成的。

### 同时依据上文，有两点是OIer常犯的错误。  

1. 将变量声明到主函数中。
>> 函数中定义的变量是该函数的**局部变量**。它们在其他函数的语句中是不可见的，通常无法访问它们。   
> 值得注意的是，main()函数，即主函数也是一种函数，其中的变量也是局部变量，随函数一起进入系统堆栈。占用系统堆栈的本来就小的空间。  
2. 认为bool空间更小，数组可以开很大。实际上bool数组和char数组一样大，很多时候空间够用，bool开得很大也没问题，但是真要开很大还是用bitset吧。
>> 大多数情况空间够用，无需纠结这一点。

## 参数

函数的**参数**大家都不陌生，就是长得像下面这一段代码中，函数定义时括号内的东西。
![function](/简谈函数参数与调用中的坑/function.png)

但是，对于参数而言，它的坑却很多。  
根据表达式求值的经验，我们会认为函数的参数是从左向右进行的。
对于下面的例子而言，我们先预计一下它的输出结果。"1, 2, 3"
```cpp
int main(){
    int j = 1;
	printf("%d, %d, %d", j++, j++, j++);
    // cout << j++ << j++ << j++; 是一样的
	return 0;
}
```
实际呢？ "3, 2, 1"
？？？ 这是怎么回事，难道是std::printf(), std::cout 的锅？

我们看下面这个稍微复杂的例子， 在这之前，我们先（根据经验）确定一个事实：
> c++ 函数的参数在进入函数之前计算完毕。
```cpp
#include <cstdio>
using namespace std;
int i = 1; int j = 1;
int f1(){ 
    printf("f1 ");
	return ++i; 
}
int f2(){
	printf("f2 ");
	return ++i;
}
int f3(){
	printf("f3 ");
	return ++i;
}
void print(int a, int b, int c){
	printf("\n %d, %d, %d", a, b, c);
}
int main(){
	print(f3(),f2(),f1());
	print(j++, j++, j++);
	return 0;
}
```
在这里，我们自定义了一个函数$print()$和三个函数$f1(), f2(), f3()$。（滥用LaTeX系列）  
$f1(), f2(), f3()$还特别加了一个$printf()$表示他们执行的次序。
刚才的事实也可以从定义的三个函数可以看出，在$f1(), f2(), f3()$ **相继**处理完后，参数进入函数中。   
所以可以得出一条经验，函数中的参数从右向左*处理*（后面我们会对这个处理进行进一步的解释）  

现在放出大招  
```cpp
int a = 10;
printf("%d, %d, %d, %d", a++, ++a, a, a++);//ps. 如果你还不明白++a 与 a++的区别，你需要学习一下语法了。
```



等一下，我知道，我知道，不就是"12, 12, 11, 10" 吗？   
根据刚才的经验，好像是这样从右往左的顺序。 实际呢？ "12, 13, 13, 10"  
??????? (问号脸，~~不想放图，我本地还不能预览~~)

要处理这个问题，我们还要深入♂了解一下函数的调用机制，和表达式求值。  

## 调用

具体实现和探究中的代码我就不写了，[文章链接](https://www.cnblogs.com/findumars/p/7545818.html)

等等，我们第一章讲啥了？ 堆栈(stog? ~~staza!~~)  
回到堆栈，实际上它就是一个栈，只不过，堆栈一般就指函数栈。   
首先要记住，局部变量不存在于**堆**，不是所有人（函数）都能访问它，它只能将它的值通过堆栈传递过去。  
在一个函数*被*调用时，调用者将它的所有参数入栈，这个入栈顺序是有规定的，总的来说，是从右到左入栈。    

而对于所有参数，他们必须是一个已计算完毕的值，因此在参数入栈的的时候，会计算每个表达式及函数的值，然后在将其传入堆栈。  
> 3) 调用函数时（无论函数是否内联，且无论是否使用显式函数调用语法），与任何实参表达式或与指代被调用函数的后缀表达式关联的每个值计算和副作用，都按顺序早于被调用函数体内的每个表达式或语句的执行。  --c++参考手册  

而这些有**副作用**（记住副作用）的表达式、函数，表现的就不如人意了。  

顺带一提，其他函数内的局部变量并不会修改当前函数的局部变量。对于$swap()$这样的东西，你需要用引用传递参数。  

我们是不是还有一个问题没有解决，对了，关于a++和a为什么是13，引用博客：

> 对于c/c++函数参数的读取顺序，参数入栈时顺序的确是从右向左入栈，但是在入栈前会先把参数列表里的表达式从右向左算一遍得到表达式的结果，最后再把这些运算结果统一入栈。也就是说在参数入栈前，编译器会先把参数的表达式都处理掉，哪怕这些运算会改变其中某些参数的值；然后对于一般的操作来说，参数入栈时取值是直接从变量的内存地址里取的，但是对于a++操作，编译器会开辟一个缓冲区来保存当前a的值，然后再对a继续操作，最后参数入栈时的取值是从缓冲区取，而不是直接从a的内存地址里取。因此，对于下面的程序：  
> a=10;printf("%d %d %d\n",a++,++a,a,a++)   
> 最后的结果是12 13 13 10。具体解析：  
> 首先从右向左处理表达式，最后a的结果变成13.但是在处理a++的时候，从最右边开始，第一个a++放进缓冲区的值为10，第二个a++放进缓冲区的值为12.因此最后处理结果如上。注意++a和a的值都是直接从a的内存中取出来的，都是13.  
> 
> --------------------- 
> 版权声明：本文为CSDN博主「yuerZ6」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/u010141928/article/details/72904193   

可能是这样的，也可能不是，至于为什么，你可以点击上文链接，也可以接着往下读。

## 表达式求值顺序

有小朋友来问我，叔叔自增自减运算符有几个写法啊？  
我说，我见得太多了，c++参考手册，比你们不知道高到哪里去了。（逃

-----------

广告时间  

你是否有做过想这样的题：
```cpp
int i = 0;
printf("%d %d %d %d", i++, ++i, --i, i--);
```
是。。。而不是。。。，为什么？

你是否在某本教科书上看见过：
```cpp
int i = 0
i = i++;
```
或是
```cpp
a+++++a, a++*++a
```
的值分别是多少？   
你是否厌倦了这样\*\*的题目。  
还不赶紧电话订购《c++prime》或访问https://zh.cppreference.com/w/cpp。

广告结束

-----------


我们来想，这些困扰我们的题目问题出现在什么地方。对，他们修改了变量，产生了某种副作用。  
所以我们实际上要解决，如果一个变量被修改了，那么，它在什么时间会反映到内存上。  

在这里，c++参考手册给出了一个关于变量副作用的顺序点的定义：
> 序列点规则 (C++11 前)  
>> 定义  
>> 表达式的求值可能产生副作用，包括：访问 volatile 左值所指代的对象，修改对象，调用库 I/O 函数，或调用做任何这些动作的函数。  
>
>> 序列点 (sequence point)是执行序列中的点，在该点所有来自序列中先前求值的副作用均已完成，而后继求值的副作用都未开始。

至于为什么是c++11前，OIer心里有数（~~unordered_map想你~~ 手写蛤烯跑的飞快）  

> 规则
> 1) 每个全表达式结尾（典型地在分号处）有一个序列点。
> 2) 调用函数时（无论该函数是否内联，无论是否使用函数调用语法），所有函数实参的求值（若存在）之后有一个序列点，它发生于函数体内的任何表达式或语句的执行之前。
> 3) 对函数的返回值进行复制之后，并在函数外任何表达式的执行之前有一个序列点。
> 4) 一旦函数执行开始，则在被调用函数的执行完成前，不求值调用方函数的任何表达式（函数不能交错执行）。
> 5) 每个使用内建（非重载）运算符的下列四种表达式的求值中，表达式 a 的求值后有一个序列点。
>> ```cpp
>> a && b
>> a || b
>> a ? b : c
>> a , b
>> ```

最重要的来了
> 未定义行为
>> 1) 前后序列点间，至多可以修改标量对象的存储值一次，否则其行为未定义。
>> ```cpp
>> i = ++i + i++; // 未定义行为
>> i = i++ + 1; // 未定义行为（ C++17 前）
>> i = ++i + 1; // 未定义行为（ C++11 前）
>> ++ ++i; // 未定义行为（ C++11 前）
>> f(++i, ++i); // 未定义行为（ C++17 前）
>> f(i = -1, i = -1); // 未定义行为（ C++17 前）
>> ```
>> 2) 前后序列点间，访问表达式求值所修改的标量对象的先前值，必须只为确定要存储的值。若以任何其他方式访问，则其行为未定义。
>> ```cpp
>> cout << i << i++; // 未定义行为（ C++17 前）
>> a[i] = i++; // 未定义行为（ C++17 前）
>> ```

换句话说， 在一个分号之前，或函数的所有参数（不是每个）求值结束之前，都不应该有对同一变量及其引用的多次修改。  
否则，这些行为在c++规范中，都是**未定义的**。  
也就是说，**任意**c++编译器对这种行为顺序的**任意改变**，都是符合c++规范的。每一个副作用的发生时间都由具体的编译器按照某种顺序定义，而这种定义对我们来说可以是任意的。  

我们再回到（类似）一开始的例子，
```cpp
int i = 3;  
printf("%d, %d, %d\n",i++, ++i, i);  
```
![VC6.0](/简谈函数参数与调用中的坑/VC6.png)
![LinuxDec-C++](/简谈函数参数与调用中的坑/linuxDev.png)  

所以，对于不同的环境，这些东西是不同的，但都合法。

## 总结
c++中函数参数调用时，会将其中所有表达式及函数从右往左以此求值并入栈。但是，对于在一个函数的括号内（同一个函数的多个参数），或是一个分号前，多次修改一个变量的值，是**未定义的**，其副作用表现时间由不同环境及不同编译器确定。也就是说，讨论这种例子是无意义的。  
同时我们也要留意加边时如：
```cpp
void addEdge(int from, int to, int dist){...}
...
addEdge(read(),read(),read());
...
```
的时候会变得十分诡异。  
需要将参数的顺序调换位置，或是增加中间变量。

还有，编译时请打开-Wall, 编译器会提示你： operation on ... may be undefined(未定义行为)。
